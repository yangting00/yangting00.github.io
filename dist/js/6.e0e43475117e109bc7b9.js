webpackJsonp([6],{347:function(s,a){s.exports='<hr>\n<p>createTime : 2017/06/28<br>author : 候志强</p>\n<h2 id="title-javascript-">title : JAVASCRIPT基础</h2>\n<p>本文主要讲述了JavaScript语言中基本知识和概念以及平时工作时遇到的一些问题。</p>\n<h3 id="-javascript">为什么需要深入了解JavaScript</h3>\n<p>  首先，作为前端工程师，无论在学习新的框架和技术，还是工作开发中，都要不断的阅读JavaScript代码，因此越深入JavaScript的基础，就能更好的理解别人的代码，也能更好的创造出自己的写法，提高自己的开发效率。同时在追踪一些bug时，也能根据JavaScript的基础知识来判断问题的原因（比如异步的一些问题），更快速的定位问题。</p>\n<p>本文所讲的JavaScript基础的主要内容包括：</p>\n<ol>\n<li>变量和作用域</li>\n<li>对象和原型</li>\n<li>函数</li>\n<li>面向对象编程</li>\n<li>异步编程</li>\n</ol>\n<h3 id="-">变量和作用域</h3>\n<h4 id="javascript-">JavaScript是动态类型、直译语言</h4>\n<p>  动态类型是指在声明变量时，不需要指定类型，也就是说变量可以存放任何类型的数据，直译语言是指在代码是在运行时解释执行的。同时JavaScript也是一个基于原型的语言（下一节会讲到），也是一门多范式语言，它支持面向对象编程，命令式编程以及函数式编程。<br>  在语法上JavaScript与C语言有很多相似的地方，比如判断和循环等</p>\n<h4 id="javascript-">JavaScript的数据类型</h4>\n<p>  虽然JavaScript的变量没有类型，但是数据是区分类型的。JavaScript的数据类型分为两大类：基本数据类型和引用类型。<br>  基本数据类型包括：<code>undefined</code> <code>null</code> <code>boolean</code> <code>number</code> <code>string</code> 五种<br>  引用类型是除了基本数据类型以外的所有数据类型，包括数组、对象和原生对象等等<br>  可以通过typeof来判断数据属于哪种基本数据类型，以下表达式的值都为true：</p>\n<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">\'undefined\'</span>  </div><div class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">\'object\'</span> <span class="comment">//  判断null时可以考虑使用===来判断而不是用typeof</span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">true</span> === <span class="string">\'boolean\'</span></div><div class="line"><span class="keyword">typeof</span> <span class="number">123</span> === <span class="string">\'number\'</span> </div><div class="line"><span class="keyword">typeof</span> <span class="string">\'123\'</span> === <span class="string">\'string\'</span></div></pre></td></tr></table></figure><h4 id="-">小数运算的问题</h4>\n<p>  考虑这个表达式的结果<code>0.7+0.1</code>，我们期望的结果是<code>0.8</code>，但是运算后的结果却是：<code>0.7999999999</code>,为什么会出现这个问题呢？<br>  由于JavaScript只有双精度浮点数字类型（不像Java那样区分整型和浮点型），对于JavaScript来说，<code>1.0 === 1</code> 是为true的。在JavaScript内部使用IEEE754格式来存储数值，但是这种格式无法准确的用二进制来表示某些十进制小数，这样就带来了小数运算时的精度问题。<br>  由于一般情况下我们不需要那么高的精读，所以我们可以通过四舍五入的方式来实现我们想要的结果。比如把上面的结果四舍五入保留一位小数后就会变成我们想要的<code>0.8</code>了。</p>\n<h4 id="-">四舍五入的问题</h4>\n<p>  那一般我们用什么做四舍五入呢？有人会想到原生的<code>toFixed</code>方法，这里我们可以看一下从知乎中一个问题的<a href="https://www.zhihu.com/question/37639441">讨论</a>：</p>\n<blockquote>\n<p>通过查看<code>toFixed</code>方法在ECMA-262 5.1 Edition标准中的定义<br>```<br>15.7.4.5 Number.prototype.toFixed (fractionDigits)</p>\n</blockquote>\n<p>Return a String containing this Number value represented in decimal fixed-point notation with fractionDigits<br>digits after the decimal point. If fractionDigits is undefined, 0 is assumed. Specifically, perform the following<br>steps: </p>\n<ol>\n<li>Let f be ToInteger(fractionDigits). (If fractionDigits is undefined, this step produces the value 0). </li>\n<li>If f &lt; 0 or f &gt; 20, throw a RangeError exception. </li>\n<li>Let x be this Number value. </li>\n<li>If x is NaN, return the String &quot;NaN&quot;. </li>\n<li>Let s be the empty String. </li>\n<li>If x &lt; 0, then<br>a. Let s be &quot;-&quot;.<br>b. Let x = –x. </li>\n<li>If x &gt;= 10^21, then<br>a. Let m = ToString(x). </li>\n<li>Else, x &lt; 10^21<br>a. Let n be an integer for which the exact mathematical value of n / 10^f – x is as close to zero as possible. If there are two such n, pick the larger n.<br>b. If n = 0, let m be the String &quot;0&quot;. Otherwise, let m be the String consisting of the digits of the decimal representation of n (in order, with no leading zeroes).<br>c. If f != 0, then<br> i. Let k be the number of characters in m.<br> ii. If k ≤ f, then <ol>\n<li>Let z be the String consisting of f+1–k occurrences of the character &#39;0&#39;. </li>\n<li>Let m be the concatenation of Strings z and m. </li>\n<li>Let k = f + 1.<br>iii. Let a be the first k–f characters of m, and let b be the remaining f characters of m.<br>iv. Let m be the concatenation of the three Strings a, &quot;.&quot;, and b. </li>\n</ol>\n</li>\n<li>Return the concatenation of the Strings s and m.<br>```</li>\n</ol>\n<blockquote>\n<p>根据上述步骤<br>9.655.toFixed(2)的过程在8中<br>```</p>\n<ol>\n<li>f = 2</li>\n<li>x = 9.655</li>\n<li>s = &#39;&#39;<br>8.</li>\n</ol>\n</blockquote>\n<p>  a. n = 965<br>    原因<br>    当 n = 965 时 n / 10^f – x = -0.004999999999999005<br>    当 n = 966 时 n / 10^f – x = 0.005000000000000782<br>    965更靠近0<br>  b. m = &#39;965&#39;<br>  c.<br>    i. k = 3<br>    iii. a = &#39;9&#39;, b = &#39;65&#39;<br>    iv. m = a + &#39;.&#39; + b = &#39;9.65&#39;</p>\n<ol>\n<li>Return s + m = &#39;9.65&#39;<br>```</li>\n</ol>\n<p>由上面可以看到，实际上受精度影响，在乘法除法进行移位时，会造成误差，导致<code>toFixed</code> 进行四舍五入也是不准确的，所以如果想要精确的运算结果，可以使用MDN上提供的一种<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round">方法</a>来进行四舍五入</p>\n<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Closure</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</div><div class="line">  <span class="comment">/**</div><div class="line">   * Decimal adjustment of a number.</div><div class="line">   *</div><div class="line">   * @param {String}  type  The type of adjustment.</div><div class="line">   * @param {Number}  value The number.</div><div class="line">   * @param {Integer} exp   The exponent (the 10 logarithm of the adjustment base).</div><div class="line">   * @returns {Number} The adjusted value.</div><div class="line">   */</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">decimalAdjust</span>(<span class="params">type, value, exp</span>) </span>{</div><div class="line">    <span class="comment">// If the exp is undefined or zero...</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exp === <span class="string">\'undefined\'</span> || +exp === <span class="number">0</span>) {</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>[type](value);</div><div class="line">    }</div><div class="line">    value = +value;</div><div class="line">    exp = +exp;</div><div class="line">    <span class="comment">// If the value is not a number or the exp is not an integer...</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(value) || !(<span class="keyword">typeof</span> exp === <span class="string">\'number\'</span> &amp;&amp; exp % <span class="number">1</span> === <span class="number">0</span>)) {</div><div class="line">      <span class="keyword">return</span> <span class="literal">NaN</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// If the value is negative...</span></div><div class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) {</div><div class="line">      <span class="keyword">return</span> -decimalAdjust(type, -value, exp);</div><div class="line">    }</div><div class="line">    <span class="comment">// Shift</span></div><div class="line">    value = value.toString().split(<span class="string">\'e\'</span>);</div><div class="line">    value = <span class="built_in">Math</span>[type](+(value[<span class="number">0</span>] + <span class="string">\'e\'</span> + (value[<span class="number">1</span>] ? (+value[<span class="number">1</span>] - exp) : -exp)));</div><div class="line">    <span class="comment">// Shift back</span></div><div class="line">    value = value.toString().split(<span class="string">\'e\'</span>);</div><div class="line">    <span class="keyword">return</span> +(value[<span class="number">0</span>] + <span class="string">\'e\'</span> + (value[<span class="number">1</span>] ? (+value[<span class="number">1</span>] + exp) : exp));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Decimal round</span></div><div class="line">  <span class="keyword">if</span> (!<span class="built_in">Math</span>.round10) {</div><div class="line">    <span class="built_in">Math</span>.round10 = <span class="function"><span class="keyword">function</span>(<span class="params">value, exp</span>) </span>{</div><div class="line">      <span class="keyword">return</span> decimalAdjust(<span class="string">\'round\'</span>, value, exp);</div><div class="line">    };</div><div class="line">  }</div><div class="line">  <span class="comment">// Decimal floor</span></div><div class="line">  <span class="keyword">if</span> (!<span class="built_in">Math</span>.floor10) {</div><div class="line">    <span class="built_in">Math</span>.floor10 = <span class="function"><span class="keyword">function</span>(<span class="params">value, exp</span>) </span>{</div><div class="line">      <span class="keyword">return</span> decimalAdjust(<span class="string">\'floor\'</span>, value, exp);</div><div class="line">    };</div><div class="line">  }</div><div class="line">  <span class="comment">// Decimal ceil</span></div><div class="line">  <span class="keyword">if</span> (!<span class="built_in">Math</span>.ceil10) {</div><div class="line">    <span class="built_in">Math</span>.ceil10 = <span class="function"><span class="keyword">function</span>(<span class="params">value, exp</span>) </span>{</div><div class="line">      <span class="keyword">return</span> decimalAdjust(<span class="string">\'ceil\'</span>, value, exp);</div><div class="line">    };</div><div class="line">  }</div><div class="line">})();</div><div class="line"></div><div class="line"><span class="comment">// Round</span></div><div class="line"><span class="built_in">Math</span>.round10(<span class="number">55.55</span>, <span class="number">-1</span>);   <span class="comment">// 55.6</span></div><div class="line"><span class="built_in">Math</span>.round10(<span class="number">55.549</span>, <span class="number">-1</span>);  <span class="comment">// 55.5</span></div><div class="line"><span class="built_in">Math</span>.round10(<span class="number">55</span>, <span class="number">1</span>);       <span class="comment">// 60</span></div><div class="line"><span class="built_in">Math</span>.round10(<span class="number">54.9</span>, <span class="number">1</span>);     <span class="comment">// 50</span></div><div class="line"><span class="built_in">Math</span>.round10(<span class="number">-55.55</span>, <span class="number">-1</span>);  <span class="comment">// -55.5</span></div><div class="line"><span class="built_in">Math</span>.round10(<span class="number">-55.551</span>, <span class="number">-1</span>); <span class="comment">// -55.6</span></div><div class="line"><span class="built_in">Math</span>.round10(<span class="number">-55</span>, <span class="number">1</span>);      <span class="comment">// -50</span></div><div class="line"><span class="built_in">Math</span>.round10(<span class="number">-55.1</span>, <span class="number">1</span>);    <span class="comment">// -60</span></div><div class="line"><span class="built_in">Math</span>.round10(<span class="number">1.005</span>, <span class="number">-2</span>);   <span class="comment">// 1.01 -- compare this with Math.round(1.005*100)/100 above</span></div><div class="line"><span class="built_in">Math</span>.round10(<span class="number">-1.005</span>, <span class="number">-2</span>);  <span class="comment">// -1.01</span></div><div class="line"><span class="comment">// Floor</span></div><div class="line"><span class="built_in">Math</span>.floor10(<span class="number">55.59</span>, <span class="number">-1</span>);   <span class="comment">// 55.5</span></div><div class="line"><span class="built_in">Math</span>.floor10(<span class="number">59</span>, <span class="number">1</span>);       <span class="comment">// 50</span></div><div class="line"><span class="built_in">Math</span>.floor10(<span class="number">-55.51</span>, <span class="number">-1</span>);  <span class="comment">// -55.6</span></div><div class="line"><span class="built_in">Math</span>.floor10(<span class="number">-51</span>, <span class="number">1</span>);      <span class="comment">// -60</span></div><div class="line"><span class="comment">// Ceil</span></div><div class="line"><span class="built_in">Math</span>.ceil10(<span class="number">55.51</span>, <span class="number">-1</span>);    <span class="comment">// 55.6</span></div><div class="line"><span class="built_in">Math</span>.ceil10(<span class="number">51</span>, <span class="number">1</span>);        <span class="comment">// 60</span></div><div class="line"><span class="built_in">Math</span>.ceil10(<span class="number">-55.59</span>, <span class="number">-1</span>);   <span class="comment">// -55.5</span></div><div class="line"><span class="built_in">Math</span>.ceil10(<span class="number">-59</span>, <span class="number">1</span>);       <span class="comment">// -50</span></div></pre></td></tr></table></figure><p>上面代码也可以看到，如果直接使用<code>Math.round(1.005*100)/100</code>这种方式也是不精确的，其结果是1，而不是预想的1.01。<br>这里的代码提供了安全的移位方式，通过科学计数法的方式来进行移位。以上的代码提供了对Math下round、floor和ceil的封装，增强了这三个函数的功能。</p>\n<h4 id="-">变量的赋值</h4>\n<p>  基本数据类型的赋值和引用类型的赋值方式有所不同。基本数据类型为值传递，而引用类型是引用传递，目的是减少内存开销和对比开销，当引用类型对比时，只是对比的引用是否相同，而不是像基本类型对比一样，进行值的对比。<br>  请参考下面的代码：</p>\n<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">\'123\'</span></div><div class="line"><span class="keyword">var</span> b = a;</div><div class="line">a = a + <span class="string">\'456\'</span></div><div class="line">a === b <span class="comment">// false</span></div><div class="line"></div><div class="line">a = { <span class="attr">x</span> : <span class="number">1</span> }</div><div class="line">b = a</div><div class="line">a.x = <span class="number">2</span>;k</div><div class="line">a === b <span class="comment">// true</span></div></pre></td></tr></table></figure><h4 id="-">复制变量</h4>\n<p>  由于像对象这种引用类型的赋值为引用传递，会在工作中造成一些非常隐蔽的问题，比如通过参数传进来的对象和数组，在函数内部被修改，会引起外部无法预料的情况，所以如果不想对外部环境在成影响，就需要对对象或数组进行复制。<br>  以下以对象的复制为例，一般对象复制分为深复制和浅复制。<br>  浅复制一般实现方式是对对象自身所包含的属性进行遍历，对每个属性通过赋值操作赋值到新对象上的同名属性的操作（无论是否是引用类型），一般可以通过<code>Object.assign</code>方法或者ES7提案中的对象展开符来方便的复制<br>  深复制一般实现方式是在浅复制的基础上，判断属性是否为引用类型，如果是引用类型，再递归的对该属性进行复制的操作。<br>  请考虑下面的代码</p>\n<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherFunction</span>(<span class="params"></span>)</span>{}</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherObject = {</div><div class="line">  <span class="attr">c</span>:<span class="literal">true</span>,</div><div class="line">}</div><div class="line"><span class="keyword">var</span> anotherArray = []</div><div class="line"><span class="keyword">var</span> myObject = {</div><div class="line">  <span class="attr">a</span>:<span class="number">2</span>,</div><div class="line">  <span class="attr">b</span>:anotherObject,</div><div class="line">  <span class="attr">c</span>:anotherArray,</div><div class="line">  <span class="attr">d</span>:anotherFunction,</div><div class="line">}</div><div class="line">anotherArray.push(anotherObject, myObject)</div></pre></td></tr></table></figure><p>如果想深复制<code>myObject</code>这个对象，当遍历属性时，会遇到anotherArray属性，当我递归的复制它的c属性时，它引用了<code>myObject</code>对象，如果不加判断的递归就会导致死循环，所以深复制时要注意循环引用的问题。当复制d属性时，也会出现问题，函数是没有办法进行复制的。而且复制函数也没有意义。<br>除了使用递归的方式，也可以使用<code>JSON.stringify</code>和<code>JSON.parse</code>来进行简单的复制，但是要注意错误处理，同时也注意上面提到的问题，如不要包含函数和循环引用的问题。</p>\n<h4 id="-">作用域和作用域链</h4>\n<p>作用域是指变量在程序中作用的范围，换句话说，当获取一个变量的值的时候，语言引擎获取值的一种规则。作用域分为两种：动态作用域和静态作用域。<br>动态作用域是指：根据函数的调用链来确定变量的可见范围。<br>静态作用域是指：根据函数定义（对于JavaScript来说）的文本环境来确定变量的可见范围。函数定义内可见，函数定义外部不可见。JavaScript就属于静态作用域。<br>当使用var定义变量时，定义的变量就会在当前作用域（ES6之前只有函数作用域），不使用var则定义在全局环境<br>作用域链是指：当在函数内部定义函数，也就是作用域嵌套时，则内部作用域能访问外部作用域的变量（当内部作用域无此变量时），此访问链称为作用域链<br>通过利于外部作用域无法访问内部作用域变量的特点，可以实现隐藏内部实现的功能，防止内部变量被意外篡改，引发异常。</p>\n<h4 id="-">闭包</h4>\n<p>闭包是指一个函数持有一个外部函数作用域中变量的引用。一般如果一个函数作为变量被返回一般就会发生闭包。请看下面一个经典例子：</p>\n<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span> ; i++){</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>{</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  }, i*<span class="number">1000</span>);</div><div class="line">}</div></pre></td></tr></table></figure><p>我们期望的结果是每隔一秒输出1~5这5个数字，结果确实一直是6。由于timer形成了闭包，只是拿了i的一个外部引用，当延迟执行的时候，i值已经被for循环改为6了，所以我们通过每次创建一个新的作用域来暂存住i的值，如下：</p>\n<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span> ; i++){</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</div><div class="line">    <span class="keyword">var</span> j = i;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>{</div><div class="line">      <span class="built_in">console</span>.log( j );</div><div class="line">    }, i*<span class="number">1000</span>);</div><div class="line">  })()</div><div class="line">}</div></pre></td></tr></table></figure><p>这样就能如我们预期的一样了。这里有一点需要注意：如果i是一个引用类型，则要复制i的值，而不是赋值，来防止引用赋值的问题。</p>\n<h5 id="-">变量提升</h5>\n<p>考虑下面的代码：</p>\n<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> v = <span class="string">\'Hello World\'</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</div><div class="line">  <span class="built_in">console</span>.log(v)</div><div class="line">  <span class="keyword">var</span> v = <span class="string">\'thanks\'</span></div><div class="line">})()</div></pre></td></tr></table></figure><p>这里会输出什么呢？结果是<code>undefined</code>,这里是由于变量提升的原因，也就是说变量提升只提升变量的定义，不提升变量赋值。</p>\n<h4 id="-">对象和原型链</h4>\n<p>JavaScript中定义一个对象非常的方便，可以使用对象字面量的方式进行定义，本质上是一种哈希表的实现。<br>JavaScript对象上有一个特殊的内部属性：原型<code>[[Prototype]]</code>，它只是一个其他对象的引用。几乎所有的对象在被创建时，它的这个属性都被赋予了一个非null值。<br>请考虑下面的代码：</p>\n<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> anotherObject = {</div><div class="line">  <span class="attr">a</span>:<span class="number">2</span>,</div><div class="line">}</div><div class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</div><div class="line">myObject.a; <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>上面的代码通过<code>Object.create</code>方法使<code>myObject</code>的原型指向了<code>anotherObject</code>，显然<code>myObject.a</code>实际上不存在，但是引擎从<code>anotherObject</code>上找到并返回了值<code>2</code>，如果在<code>`anotherObject上也没找到</code>a<code>，而且如果它的原型链不为空，就沿着它的原型链继续查找，以此类推，直到找到a属性或者到达原型链的终点，如果在终点也没找到，则会返回</code>undefined<code>，一般对象的原型链重点是</code>Object.prototype`</p>\n<h4 id="-">函数</h4>\n<p>JavaScript中的函数是一种特殊的对象，可以赋值给变量，并且和对象一样可以拥有自己的属性，但与一般对象不同的是，在创建时会自动包含prototype属性，并且prototype其中包含constructor并指向自身</p>\n<h4 id="-this-">函数中的<code>this</code></h4>\n<p>函数中的this不是编写时绑定，而是运行时绑定，它是根据函数在代码中调用的位置（不是被声明的位置）决定的，也就是说他和函数的调用栈（call-stack）有关系。<br>this的绑定遵循四种规则：</p>\n<ul>\n<li>默认绑定：独立的函数调用，也就是直接通过函数名调用，this会指向全局对象，在严格模式下会被设置为<code>undefined</code></li>\n<li>隐藏绑定：函数属于某个对象的方法，通过该对象去调用，this会指向该对象。比如<code>obj</code>上有一个方法<code>f</code>，通过<code>obj.f()</code>调用，则f中的this指向为obj。但是如果当把<code>var b = obj.f</code>赋值给b后，再去<code>b()</code>，则会按照默认绑定规则，如果作为回调函数，情况也是如此。</li>\n<li>明确绑定：通过call或apply调用函数，指定this的指向。如果再用一个函数包装起来，则称为硬绑定，类似与通过ES5中的<code>bind</code>方法，this绑定固定后将无法改变</li>\n<li>new绑定：在JavaScript中被new调用，则函数被作为构造器，引擎会创造一个新的对象作为调用中的this。这个会在后面详细讲到</li>\n</ul>\n<h5 id="-">绑定优先级</h5>\n<p>从下到上 new绑定 &gt; 明确绑定 &gt; 隐藏绑定 &gt; 默认绑定</p>\n<h5 id="-">箭头函数</h5>\n<p>前面讲的函数都是指一般的函数。箭头函数作为一种特殊的函数，它内部的this绑定由词法作用域决定的（不是运行时绑定，而是编写时绑定），类似于在外部把this赋值给self，然后在箭头函数内部使用self</p>\n'}});